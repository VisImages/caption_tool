[{"ImageID": 0, "Page": 1, "Type": "Figure", "Imagebbox": [0.08671586715867159, 0.12446018687465735, 0.9247448979591837, 0.2364709830959799], "Caption": "Fig. 1. A non-sliceable treemap (a treemap that cannot be recursively sliced into two parts) over time. In each image the weights of the underlying data have changed. To maintain a balance between aspect ratio and stability we modify the treemap via local moves. Symbols (squares, circles, and triangles) mark the pairs of rectangles to which local moves are applied.", "DPI": 100, "CaptionBB": [73, 261, 724, 303], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 1, "Page": 2, "Type": null, "Imagebbox": [0.38191881918819187, 0.19733468080178285, 0.48523985239852396, 0.27155870239422547], "Caption": null, "DPI": null, "CaptionBB": null, "first_confirmed": false, "second_confirmed": false}, {"ImageID": 2, "Page": 3, "Type": "Figure", "Imagebbox": [0.6088560885608856, 0.7209514149448328, 0.8745387453874539, 0.7927170868347339], "Caption": "Fig. 6. A stretch move at the upper endpoint of the maximal segment s.", "DPI": 100, "CaptionBB": [405, 862, 755, 878], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 3, "Page": 3, "Type": "Figure", "Imagebbox": [0.6237244897959183, 0.04855275443510738, 0.8571428571428571, 0.11671335200746966], "Caption": "Fig. 5. Let a1 = 1 and a2 = a3 = a4 = a5 = 16. The maximum aspect ratio in the non-sliceable layout on the right is \u2248 1.333. For any sliceable layout the maximum aspect ratio is at least 4.", "DPI": 100, "CaptionBB": [405, 140, 755, 176], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 4, "Page": 3, "Type": "Figure", "Imagebbox": [0.16964285714285715, 0.04948646125116713, 0.38137755102040816, 0.12044817927170867], "Caption": "Fig. 3. Two order-equivalent layouts: the blue arrows indicate the partial order on the vertical maximal segments, the red arrows indicate the partial order on the horizontal maximal segments.", "DPI": 100, "CaptionBB": [40, 142, 390, 184], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 5, "Page": 3, "Type": "Figure", "Imagebbox": [0.6135204081632653, 0.8524743230625583, 0.8673469387755102, 0.9197012138188608], "Caption": "Fig. 6. A stretch move at the upper endpoint of the maximal segment s.", "DPI": 100, "CaptionBB": [405, 862, 755, 878], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 6, "Page": 3, "Type": null, "Imagebbox": [0.3966789667896679, 0.37817138795427946, 0.492619926199262, 0.46049257553862494], "Caption": null, "DPI": null, "CaptionBB": null, "first_confirmed": false, "second_confirmed": false}, {"ImageID": 7, "Page": 4, "Type": "Figure", "Imagebbox": [0.13137755102040816, 0.5957049486461251, 0.3966789667896679, 0.7049486461251168], "Caption": "Fig. 9. Rectangle R1 and R2 are flipped using a flip move: s has two We first consider only a single-level treemap T . We construct the less rectangles adjacent to it. initial treemap using the approximation algorithm by Nagamochi and", "DPI": 100, "CaptionBB": [28, 754, 743, 785], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 8, "Page": 4, "Type": "Figure", "Imagebbox": [0.13137755102040816, 0.4584500466853408, 0.3985239852398524, 0.5611577964519141], "Caption": "way to find these moves. Clearly the resulting transformation is not Fig. 8. Rectangle R2 is stretched over rectangle R1 : s has one less very natural and we do not intend to use this transformation. Now that rectangle adjacent to it.", "DPI": 100, "CaptionBB": [28, 600, 743, 637], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 9, "Page": 4, "Type": "Figure", "Imagebbox": [0.06505102040816327, 0.8524743230625583, 0.45408163265306123, 0.9197012138188608], "Caption": "Fig. 10. Rectangles R1 and R2 are swapped using two flip moves.", "DPI": 100, "CaptionBB": [28, 999, 354, 1015], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 10, "Page": 4, "Type": "Figure", "Imagebbox": [0.5885608856088561, 0.044838054620946144, 0.8653136531365314, 0.11671335200746966], "Caption": "Fig. 11. Inverting the Flip move.", "DPI": 100, "CaptionBB": [392, 139, 549, 155], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 11, "Page": 4, "Type": "Figure", "Imagebbox": [0.5969387755102041, 0.15966386554621848, 0.8520408163265306, 0.22782446311858076], "Caption": "Fig. 12. Inverting the Stretch move.", "DPI": 100, "CaptionBB": [392, 257, 566, 273], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 12, "Page": 5, "Type": "Figure", "Imagebbox": [0.14795918367346939, 0.47432306255835666, 0.4095940959409594, 0.5546218487394958], "Caption": "Fig. 13. Rectangle Rk is inserted next to Ri by partitioning Ri into two 18. Let the layout of T be Lbest sub rectangles. 19. for all children Tc of T", "DPI": 100, "CaptionBB": [40, 593, 594, 625], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 13, "Page": 5, "Type": "Figure", "Imagebbox": [0.15178571428571427, 0.7282913165266106, 0.4022140221402214, 0.8169934640522876], "Caption": "Fig. 14. We delete the grounded rectangle R1 from the layout by stretch- algorithm is not very efficient. We address these two issues below. ing R2 and R3 over R1 . Reducing the number of layouts. We first compute all layouts", "DPI": 100, "CaptionBB": [40, 874, 737, 909], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 14, "Page": 5, "Type": "Figure", "Imagebbox": [0.5318877551020408, 0.04855275443510738, 0.9489795918367347, 0.1157796451914099], "Caption": "Fig. 15. If rectangle R1 is adjacent to multiple rectangles of all sides, we can make R1 a grounded rectangle by repeatedly applying stretch moves over an adjacent maximal segment s.", "DPI": 100, "CaptionBB": [404, 136, 756, 178], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 15, "Page": 6, "Type": "Figure", "Imagebbox": [0.5969387755102041, 0.8169934640522876, 0.8520408163265306, 0.8842203548085901], "Caption": "Fig. 19. A change occurred in the layout, but all relative positions stay the same. It is easy to track the movement of the rectangles. The relative-position-change is 0 and the layout-distance-change is 5.325.", "DPI": 100, "CaptionBB": [392, 817, 742, 859], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 16, "Page": 6, "Type": "Figure", "Imagebbox": [0.5959409594095941, 0.6804655849853186, 0.8542435424354243, 0.7507002801120448], "Caption": "Fig. 19. A change occurred in the layout, but all relative positions stay the same. It is easy to track the movement of the rectangles. The relative-position-change is 0 and the layout-distance-change is 5.325.", "DPI": 100, "CaptionBB": [392, 817, 742, 859], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 17, "Page": 6, "Type": "Figure", "Imagebbox": [0.577490774907749, 0.34578272398666815, 0.8763837638376384, 0.40709617180205415], "Caption": "Fig. 18. 25% of the area of rectangle R2 was in the NorthEast section of rectangle R1 . In the next layout 100% of the area of R2 is in the East section of R1 .", "DPI": 100, "CaptionBB": [392, 448, 742, 490], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 18, "Page": 6, "Type": "Figure", "Imagebbox": [0.7627551020408163, 0.09056956115779645, 0.9336734693877551, 0.19234360410831], "Caption": "Fig. 17. The space around rectangle R1 is subdi- vided into 8 sections.", "DPI": 100, "CaptionBB": [614, 211, 744, 253], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 19, "Page": 6, "Type": "Figure", "Imagebbox": [0.1326530612244898, 0.746031746031746, 0.38647959183673475, 0.8132586367880486], "Caption": "Fig. 16. Rectangle R1 has swapped with rectangle R2 , . . . , R5 . Even though the absolute positions have significantly changed, it is still easy to track the changes.", "DPI": 100, "CaptionBB": [28, 883, 378, 925], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 20, "Page": 7, "Type": "Figure", "Imagebbox": [0.5267857142857143, 0.3408029878618114, 0.9489795918367347, 0.5163398692810458], "Caption": "Fig. 23. A comparison between the average median aspect ratio and the average relative-position-change on the Coffee dataset. The data is averaged over the treemaps generated for each year in the Coffee dataset.", "DPI": 100, "CaptionBB": [405, 567, 755, 622], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 21, "Page": 7, "Type": "Figure", "Imagebbox": [0.06887755102040816, 0.6764170019893672, 0.492619926199262, 0.8683473389355743], "Caption": "Fig. 21. A comparison between the average relative-position-change the incremental algorithm outperforms all other algorithms on either and the average layout-distance-change of the different algorithms on the average median aspect ratio or average relative-position-change, the Coffee dataset. The average relative-position-change is depicted by and actually outperforms most algorithms on both fronts. the left columns and the average layout-distance-change is depicted by Names dataset. The second dataset consists of the 200 most popular the right columns. The data is averaged over the treemaps generated for boys and girls baby names in the Netherlands for each year in the period each year in the Coffee dataset. 1993-2015 and originates from the Nederlandse Voornamenbank [11]", "DPI": 100, "CaptionBB": [40, 929, 755, 1015], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 22, "Page": 7, "Type": "Figure", "Imagebbox": [0.5395408163265306, 0.051353874883286646, 0.9426020408163265, 0.23062558356676005], "Caption": "Fig. 22. A comparison between the average mean and average me- dian aspect ratio of the different algorithms on the Coffee dataset. The average mean aspect ratio is depicted by the left columns and aver- age median aspect ratio is depicted by the right columns. The data is averaged over the treemaps generated for each year in the Coffee dataset.", "DPI": 100, "CaptionBB": [405, 266, 757, 347], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 23, "Page": 8, "Type": "Figure", "Imagebbox": [0.5306122448979592, 0.7105508870214753, 0.9132653061224489, 0.8814192343604108], "Caption": "Fig. 26. A comparison between the average median aspect ratio and the average relative-position-change. on the Names dataset. The data is averaged over the treemaps generated for each year in the Names dataset.", "DPI": 100, "CaptionBB": [392, 962, 742, 1017], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 24, "Page": 8, "Type": "Figure", "Imagebbox": [0.03571428571428571, 0.04753710995158043, 0.9502551020408163, 0.22408963585434177], "Caption": "Fig. 24. A comparison between the average relative-position-change Fig. and the average layout-distance-change of the different algorithms on asp the Names dataset. The average relative-position-change is depicted by The the left columns and the average layout-distance-change is depicted by yea the right columns. The data is averaged over the treemaps generated for left each year in the Names dataset. colu", "DPI": 100, "CaptionBB": [28, 257, 414, 338], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 25, "Page": 9, "Type": "Figure", "Imagebbox": [0.06505102040816327, 0.04948646125116713, 0.9540816326530612, 0.49019607843137253], "Caption": "Fig. 27. A comparison of the Hilbert treemapping algorithm, our incremental treemapping algorithm, and the squarified treemapping algorithm on the trimmed Names dataset for the years 1993-1995. The dataset is trimmed to only those names that occur in every year, such that no insertions or deletions occur. One can observe that our incremental algorithm is significantly more stable than the other algorithms. This difference in stability is even more apparent in the supplementary video.", "DPI": 100, "CaptionBB": [40, 537, 755, 592], "first_confirmed": false, "second_confirmed": false}]