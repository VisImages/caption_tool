[{"ImageID": 0, "Page": 1, "Type": "Figure", "Imagebbox": [0.07627118644067797, 0.1206575682382134, 0.9152542372881356, 0.4733893557422969], "Caption": "Figure 1. Our method optimizes a layout for a series of trees and renders it using an adaptation of cushion rendering. Notably, we support topological changes to the trees such as merges and splits on all hierarchy levels. The shown example displays five time steps in the evolution of a file system hierarchy, roughly resembling the code base for this paper, where folders and files merge, split, appear, and disappear (top). Our method displays these evolving trees in a single layout paying attention to both the merges/splits as well as the hierarchical nesting (bottom).", "DPI": 100, "CaptionBB": [63, 519, 713, 587], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 1, "Page": 2, "Type": "Figure", "Imagebbox": [0.05102040816326531, 0.051492244513459906, 0.9655612244897958, 0.2567693744164332], "Caption": "Figure 2. Treemaps can be defined in different dimensions. A classic 2D layout makes excellent use of a 2D display space, but incorporating a temporal dimension is difficult. A 1D treemap layout frees up one spatial dimension for incorporating the temporal evolution of the tree.", "DPI": 100, "CaptionBB": [37, 290, 751, 319], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 2, "Page": 3, "Type": null, "Imagebbox": [0.04067796610169491, 0.058622828784119105, 0.9694915254237289, 0.2576937949010568], "Caption": null, "DPI": null, "CaptionBB": null, "first_confirmed": false, "second_confirmed": false}, {"ImageID": 3, "Page": 4, "Type": "Figure", "Imagebbox": [0.511864406779661, 0.048391469319661456, 0.9655612244897959, 0.18674136321195145], "Caption": "Figure 5. It is not always possible to draw a graph intersection-free. In particular, this is the case in our setting, where the nodes are aligned with time steps. The rendering method of Lukasczyk et al. [26] shows intersec- tions directly (top-right image), whereas they appear as discontinuities in the cushion rendering (bottom-right image) discussed in Section 4.3.", "DPI": 100, "CaptionBB": [402, 212, 754, 280], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 4, "Page": 4, "Type": "Figure", "Imagebbox": [0.05102040816326531, 0.048391469319661456, 0.49322033898305084, 0.17647058823529413], "Caption": "Figure 4. Lukasczyk et al. [26] uses Graphviz [17] to produce the graph layout in each hierarchy level independently (left). These layouts are optimized to have as few intersections as possible. But when combining all levels into a nested drawing by forcing the children to live inside their parents\u2019 space, it becomes apparent that the graph layout has no knowledge of the hierarchical nesting in G, and we get a number of intersections (right). This example has been created with the original software of [26]. Note that the underlying cause for the intersections is the violation of two hierarchical constraints in the sorting of the leaves in layer 2 , as discussed in Section 4.2 and illustrated in Figure 6. See Figure 7 for the result of our method, and Figure 3 for the underlying data.", "DPI": 100, "CaptionBB": [37, 201, 387, 361], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 5, "Page": 5, "Type": "Figure", "Imagebbox": [0.5042372881355932, 0.04684108172276223, 0.9502551020408163, 0.38468720821661995], "Caption": "Figure 6. We want to sort the red, green and blue leaves of the temporal tree T . Several constraints are imposed on their ordering due to the hierarchical nesting (yellow and orange constraints) and due to topologi- cal events (gray constraints). In order to fulfill a constraint, the involved leaves need to be next to each other in the ordering during the defined time span. Note that we only add a constraint to our system if they are not trivially fulfilled. For example, the root would always impose a hierarchical constraint on all leaves over the entire time, yet any ordering fulfills that. In this example, the two topological constraints are trivially fulfilled as well and would not actually be considered by our method. In fact, just considering the shown two hierarchical constraints suffices to properly sort the leaves. The final nested drawing is shown in Figure 7.", "DPI": 100, "CaptionBB": [395, 428, 745, 588], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 6, "Page": 5, "Type": "Figure", "Imagebbox": [0.5, 0.8762406947890818, 0.7295918367346939, 0.9514472455648926], "Caption": "Figure 7. Solving for the hierarchical constraints, the three leaves (See Figure 4) can be properly sorted and will not intersect each other in the nested drawing. Obtained with our heuristic in one single iteration.", "DPI": 100, "CaptionBB": [571, 934, 747, 1015], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 7, "Page": 7, "Type": "Table", "Imagebbox": [0.5038265306122449, 0.8328875933506692, 0.9528061224489796, 0.8948511166253101], "Caption": "Table 1. The aggregated data structure introduced in Section 3 has a significantly lower footprint, especially for filesystem data sets such as the Python data set.", "DPI": 100, "CaptionBB": [395, 953, 745, 995], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 8, "Page": 7, "Type": "Figure", "Imagebbox": [0.4987244897959184, 0.04373449131513648, 0.9528061224489796, 0.40498061660648316], "Caption": "Figure 8. Closeup of the Viscous Fingers data set from [26]. We zoomed into the time range [40, 47] to highlight the intricate structures. Note how our algorithm produces an intersection-free layout, whereas some bands are intersecting each other for the original method.", "DPI": 100, "CaptionBB": [395, 448, 745, 503], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 9, "Page": 7, "Type": "Figure", "Imagebbox": [0.5038265306122449, 0.480859010270775, 0.9528061224489796, 0.676937441643324], "Caption": "Figure 9. Layout of a nested tracking graph in the Cylinder data set. The red circles indicate regions where the original method for Nested Tracking Graphs [26] produces a layout with many intersections. Our method is able to produce a layout with just one intersection. We are looking at a temporal and spatial zoom-in covering about 15 time steps. A larger, zoomed-out version is shown in the supplemental material.", "DPI": 100, "CaptionBB": [395, 741, 747, 822], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 10, "Page": 8, "Type": "Figure", "Imagebbox": [0.5153061224489796, 0.32492997198879553, 0.9591836734693877, 0.6367880485527544], "Caption": "Figure 12. Different types of data normalization can be used with our cushion rendering method. The data in the left figures is normalized per time step, whereas the right figures show the data in absolute terms. The plots show the development of the world population until the year 2100 according to a United Nations report [35].", "DPI": 100, "CaptionBB": [402, 698, 752, 766], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 11, "Page": 8, "Type": "Figure", "Imagebbox": [0.05357142857142857, 0.5070028011204482, 0.4923469387755102, 0.6358543417366946], "Caption": "Figure 11. We fist run the heuristic for twice as many iterations as there are constraints. The approach then may choose to run into worse conditions (violate more constraints) during the Simulated Annealing part in order to not get stuck in local minima. Still, it found a configuration after 355 iterations that violates only a few topological constraints. This is a run on the Cylinder data set shown in Figure 9b.", "DPI": 100, "CaptionBB": [37, 697, 387, 778], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 12, "Page": 8, "Type": "Figure", "Imagebbox": [0.05102040816326531, 0.051492244513459906, 0.9642857142857142, 0.21942110177404295], "Caption": "Figure 10. This parameter study for the Simulated Annealing method shows that, on average, it behaves quite stable. We investigated three initial temperatures T0 (2, 5, 10), four settings for the number of iterations k until a temperatures decay occurs (5, 10, 50, 100), and three distinct settings for the temperature decay factor d (0.8, 0.85, 0.9). See Equation (7). Each bar summarizes 100 runs for the respective setting. The plots show that very good results can be obtained with any of the presented settings, but the spread of the individual runs should not be neglected. We propose to run several times, possibly in parallel, since a single run takes less than a second.", "DPI": 100, "CaptionBB": [37, 252, 752, 320], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 13, "Page": 9, "Type": "Figure", "Imagebbox": [0.5148305084745762, 0.051492244513459906, 0.9470338983050848, 0.21381886087768442], "Caption": "Figure 14. Evolution of the Python repository from 1992 until now. We can see the major development trends with some folders becoming very large and supposedly important over time.", "DPI": 100, "CaptionBB": [395, 245, 745, 287], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 14, "Page": 9, "Type": "Figure", "Imagebbox": [0.04406779661016949, 0.051492244513459906, 0.48305084745762705, 0.24684108172276223], "Caption": "Figure 14. Evolution of the Python repository from 1992 until now. We can see the major development trends with some folders becoming very large and supposedly important over time.", "DPI": 100, "CaptionBB": [395, 245, 745, 287], "first_confirmed": false, "second_confirmed": false}]