[{"ImageID": 0, "Page": 1, "Type": "Figure", "Imagebbox": [0.5877862595419847, 0.17228982300884957, 0.831764705882353, 0.27636363636363637], "Caption": "Figure 1: On the left, we show a tree dataset drawn with uniformly allocated space for each vertical node width and horizontal node height. When navigating by stretching a rubber-sheet surface, as in the right figure, the distortions allocate more screen-space to some regions of nodes and other regions are squished into less screen-space.", "DPI": 100, "CaptionBB": [440, 319, 775, 385], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 1, "Page": 2, "Type": "Figure", "Imagebbox": [0.15411764705882353, 0.06636363636363636, 0.4223529411764706, 0.5427272727272727], "Caption": "Figure 2: Top: For densely drawn regions of a dataset, we can mark several regions of interest with guaranteed visibility, and we always draw all marked regions that are smaller than a pixel. Bottom: In the identically marked tree without guaranteed visibility, these small regions may not be drawn.", "DPI": 100, "CaptionBB": [73, 608, 408, 676], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 2, "Page": 2, "Type": "Figure", "Imagebbox": [0.5247058823529411, 0.3845454545454545, 0.9070588235294118, 0.6218181818181818], "Caption": "Figure 3: PRISeq is a genome sequence visualization application built on PRISAD with the feature set of SequenceJuxtaposer [13].", "DPI": 100, "CaptionBB": [440, 698, 775, 724], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 3, "Page": 3, "Type": "Figure", "Imagebbox": [0.1635294117647059, 0.3809090909090909, 0.4047058823529412, 0.5763636363636364], "Caption": "Figure 4: Initialization of a dataset in PRISAD applications requires a world-space discretization phase, which must generate several generic components from application-specific dataset structures. The render- ing phase separates partitioning from drawing, which simplifies ap- plication drawing effort for faster pixel-based rendering performance. The blue column represents the communication required between separated generic and specific components. S, SX , and SY refer to split line hierarchies, which we introduce in Section 3.1.", "DPI": 100, "CaptionBB": [73, 648, 408, 753], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 4, "Page": 3, "Type": "Figure", "Imagebbox": [0.6141176470588235, 0.06909090909090909, 0.8223529411764706, 0.13818181818181818], "Caption": "Figure 5: A split line hierarchy is a binary tree structure that provides a linear ordering and a hierarchical subdivision of areas. For instance, the region for split line B is bounded by its parent region D, and B separates its bounded descendants A and C.", "DPI": 100, "CaptionBB": [440, 172, 775, 225], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 5, "Page": 4, "Type": "Figure", "Imagebbox": [0.5588235294117647, 0.6663636363636364, 0.8729411764705882, 0.7890909090909091], "Caption": "Figure 7: Left: Each partitioned range of leaves renders one path to the root from some leaf in its range; we only draw tree edges marked in red. The top two partitions contain single leaves, A and B, so they are the only choices. When deciding between C, D, and E, we must choose either D or E or else b will not be rendered, which would be an incorrect rendering gap. Right: Our selection traversal processes paths from the green leaf range to all subtrees with leaves in that range larger than \u03c4 . The black edges represent traversal paths and red edges stop the traversal from processing subtrees larger than \u03c4 .", "DPI": 100, "CaptionBB": [440, 880, 775, 1001], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 6, "Page": 4, "Type": "Figure", "Imagebbox": [0.19058823529411764, 0.3981818181818182, 0.3811764705882353, 0.5227272727272727], "Caption": "Figure 6: The partitioning phase of the rendering pipeline subdivides a split line hierarchy according to the sub-pixel stopping criteria \u03c4 , in this case subdividing horizontally. Widths of each horizontal par- titioned stripe, \u03b1 , \u03b2 , and \u03c7 , are narrower than \u03c4 , and partitioning does not follow the topology of the dataset.", "DPI": 100, "CaptionBB": [73, 590, 408, 656], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 7, "Page": 5, "Type": "Figure", "Imagebbox": [0.5458823529411765, 0.06545454545454546, 0.8894117647058823, 0.20636363636363636], "Caption": "Figure 8: Left: A fully rendered tree scene with several colored marks. Right: The skeleton view of the same tree, with each marked group represented as a path from node to root.", "DPI": 100, "CaptionBB": [440, 239, 775, 281], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 8, "Page": 6, "Type": "Figure", "Imagebbox": [0.5423529411764706, 0.07545454545454545, 0.8823529411764706, 0.2609090909090909], "Caption": "Figure 10: Memory performance for PRITree (PT) and TreeJuxta- poser (TJ) with several datasets.", "DPI": 100, "CaptionBB": [440, 302, 775, 328], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 9, "Page": 6, "Type": "Figure", "Imagebbox": [0.11058823529411765, 0.12727272727272726, 0.4505882352941176, 0.5227272727272727], "Caption": "Figure 9: Top: Performance time for PRITree (PT) and TreeJuxta- poser (TJ) with several datasets. Bottom: detail of lower left corner.", "DPI": 100, "CaptionBB": [73, 588, 408, 618], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 10, "Page": 6, "Type": "Figure", "Imagebbox": [0.5258823529411765, 0.3118181818181818, 0.9058823529411765, 0.38], "Caption": "Figure 11: The marking time performance, in seconds, for a classifi- cation tree from the InfoVis 2003 contest [11].", "DPI": 100, "CaptionBB": [440, 442, 775, 468], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 11, "Page": 7, "Type": "Figure", "Imagebbox": [0.10588235294117647, 0.22363636363636363, 0.45647058823529413, 0.2818181818181818], "Caption": "Figure 12: PRISeq recursively aggregates information for columns en- compassed by split lines to determine which nucleotide color should be used for the representative object. Left: No aggregation is per- formed at the highest magnification since every nucleotide is visible. Rendering column k + 2 requires drawing only a single vertical rectan- gle since C is in every sequence for that column. Center: For column range [k, k + 1], SeqB has a tie, so A is randomly chosen but the true counts are propagated upwards. Right: When aggregating all four columns, C is found to occur most frequently for SeqB.", "DPI": 100, "CaptionBB": [73, 325, 408, 443], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 12, "Page": 8, "Type": "Figure", "Imagebbox": [0.5341176470588235, 0.06636363636363636, 0.8894117647058823, 0.20636363636363636], "Caption": "Figure 14: Restricting \u03c4 to less than one-half pixel prevents gaps in rendering the set of leaves at the expense of overdrawing. Other gaps in rendering are also prevented by our tree traversal.", "DPI": 100, "CaptionBB": [440, 239, 775, 281], "first_confirmed": false, "second_confirmed": false}, {"ImageID": 13, "Page": 8, "Type": "Figure", "Imagebbox": [0.10352941176470588, 0.40545454545454546, 0.4576470588235294, 0.5463636363636364], "Caption": "Figure 13: If \u03c4 is too large, then rendering gaps are visible throughout the tree topology. The adjacent leaf ranges Lk and Lk+1 render a single leaf, which may be in pixels adjacent to pixel row Rm , rather than in row Rn itself which would be left blank.", "DPI": 100, "CaptionBB": [73, 612, 408, 669], "first_confirmed": false, "second_confirmed": false}]